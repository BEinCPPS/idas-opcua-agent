<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>services/deviceService.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">65.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">333</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">41.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">2.45</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright 2015 Telefonica Investigaci√≥n y Desarrollo, S.A.U
 *
 * This file is part of fiware-iotagent-lib
 *
 * fiware-iotagent-lib is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * fiware-iotagent-lib is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with fiware-iotagent-lib.
 * If not, seehttp://www.gnu.org/licenses/.
 *
 * For those usages not covered by the GNU Affero General Public License
 * please contact with::daniel.moranjimenez@telefonica.com
 */

&#039;use strict&#039;;

var request = require(&#039;request&#039;),
    async = require(&#039;async&#039;),
    errors = require(&#039;../errors&#039;),
    logger = require(&#039;logops&#039;),
    ngsiParser = require(&#039;./ngsiParser&#039;),
    _ = require(&#039;underscore&#039;),
    context = {
        op: &#039;IoTAgentNGSI.NGSIService&#039;
    },
    registry,
    groupRegistry,
    config;


/**
 * Generates a handler for the registration requests that checks all the possible errors derived from the registration.
 * The parameter information is needed in order to fulfill error information.
 *
 * @param {Boolen} unregister       Indicates whether this registration is an unregistration or register.
 * @param {Object} deviceData       Object containing all the deviceData needed to send the registration.
 * @return {Function}              The generated handler.
 */
function createRegistrationHandler(unregister, deviceData, callback) {
    return function handleRegistrationResponse(error, response, body) {
        if (error) {
            logger.error(context, &#039;Connection error sending registrations to the Context Broker: %s&#039;, error);
            callback(error);
        } else if (response &amp;&amp; body &amp;&amp; response.statusCode === 200) {
            var errorField = ngsiParser.getErrorField(body);

            if (errorField) {
                logger.error(context, &#039;Registration error connecting to the Context Broker: %j&#039;, errorField);
                callback(new errors.BadRequest(JSON.stringify(errorField)));
            } else {
                logger.debug(context, &#039;Registration success.&#039;);
                callback(null, body);
            }
        } else {
            var errorObj;

            logger.error(context, &#039;Protocol error connecting to the Context Broker: %j&#039;, errorObj);

            if (unregister) {
                errorObj = new errors.UnregistrationError(deviceData.id, deviceData.type);
            } else {
                errorObj = new errors.RegistrationError(deviceData.id, deviceData.type);
            }

            callback(errorObj);
        }
    };
}

/**
 * Sends a Context Provider registration or unregistration request to the Context Broker. As registrations cannot be
 * removed, an unregistration consists of an update of the existent registration to make reduce its duration to
 * 1 second.
 *
 * The entity type, entity name and lazy attributes list are needed in order to send the registration:
 *
 * @param {Boolen} unregister       Indicates whether this registration is an unregistration or register.
 * @param {Object} deviceData       Object containing all the deviceData needed to send the registration.
 */
function sendRegistrations(unregister, deviceData, callback) {
    var options = {
        url: &#039;http://&#039; + config.contextBroker.host + &#039;:&#039; + config.contextBroker.port + &#039;/NGSI9/registerContext&#039;,
        method: &#039;POST&#039;,
        json: {
            contextRegistrations: [
                {
                    entities: [
                        {
                            type: deviceData.type,
                            isPattern: &#039;false&#039;,
                            id: String(deviceData.name)
                        }
                    ],
                    attributes: [],
                    providingApplication: config.providerUrl
                }
            ],
            duration: (unregister) ? &#039;PT1S&#039; : config.deviceRegistrationDuration
        },
        headers: {
            &#039;fiware-service&#039;: deviceData.service,
            &#039;fiware-servicepath&#039;: deviceData.subservice
        }
    };

    if (deviceData.registrationId) {
        options.json.registrationId = deviceData.registrationId;
    }

    function formatAttributes(originalVector) {
        var attributeList = [];

        if (originalVector &amp;&amp; originalVector.length) {
            for (var i = 0; i &lt; originalVector.length; i++) {
                attributeList.push({
                    name: originalVector[i].name,
                    type: originalVector[i].type,
                    isDomain: &#039;false&#039;
                });
            }
        }

        return attributeList;
    }

    options.json.contextRegistrations[0].attributes = options.json.contextRegistrations[0].attributes.concat(
        formatAttributes(deviceData.lazy),
        formatAttributes(deviceData.commands)
    );

    logger.debug(context, &#039;Sending device registrations to Context Broker at [%s]&#039;, options.url);
    logger.debug(context, &#039;Using the following request:\n\n%s\n\n&#039;, JSON.stringify(options, null, 4));

    request(options, createRegistrationHandler(unregister, deviceData, callback));
}

/**
 * Process the response from a Register Context request for a device, extracting the &#039;registrationId&#039; and creating the
 * device object that will be stored in the registry.
 *
 * @param {Object} deviceData       Object containing all the deviceData needed to send the registration.
 *
 */
function processContextRegistration(deviceData, body, callback) {
    var newDevice = _.clone(deviceData);

    newDevice.registrationId = body.registrationId;

    callback(null, newDevice);
}

/**
 * Register a new device identified by the Id and Type in the Context Broker, and the internal registry.
 *
 * The device id and type are required fields for any registration. The rest of the parameters are optional, but, if
 * they are not present in the function call arguments, the type must be registered in the configuration, so the
 * service can infer their default values from the configured type. If an optional attribute is not given in the
 * parameter list and there isn&#039;t a default configuration for the given type, a TypeNotFound error is raised.
 *
 * When an optional parameter is not included in the call, a null value must be given in its place.
 *
 * @param {Object} deviceObj                    Object with all the device information (mandatory).
 */
function registerDevice(deviceObj, callback) {
    var deviceData = _.clone(deviceObj),
        fields = [&#039;service&#039;, &#039;subservice&#039;, &#039;lazy&#039;, &#039;internalAttributes&#039;, &#039;active&#039;, &#039;staticAttributes&#039;, &#039;commands&#039;],
        defaults = [null, null, [], [], [], []];

    logger.debug(context, &#039;Registering device into NGSI Service:\n%s&#039;, JSON.stringify(deviceData, null, 4));

    if (!deviceData.type) {
        deviceData.type = config.defaultType;
    }

    if (!deviceData.name) {
        deviceData.name = deviceData.id + &#039;:&#039; + deviceData.type;
        logger.debug(context, &#039;Device name not found, falling back to deviceId:type [%s]&#039;, deviceData.name);
    }

    for (var i = 0; i &lt; fields.length; i++) {
        if (config.types[deviceData.type] &amp;&amp; config.types[deviceObj.type][fields[i]]) {
            deviceData[fields[i]] =
                (deviceData[fields[i]]) ? deviceData[fields[i]] : config.types[deviceObj.type][fields[i]];
        } else {
            deviceData[fields[i]] = (deviceData[fields[i]]) ? deviceData[fields[i]] : defaults[i];
        }
    }

    if (!deviceData.service &amp;&amp; config.service) {
        deviceData.service = config.service;
    }

    if (!deviceData.subservice &amp;&amp; config.subservice) {
        deviceData.subservice = config.subservice;
    }

    async.waterfall([
        async.apply(sendRegistrations, false, deviceData),
        async.apply(processContextRegistration, deviceData),
        registry.store
    ], callback);
}

/**
 * Unregister a device from the Context broker and the internal registry.
 *
 * @param {String} id           Device ID of the device to register.
 */
function unregisterDevice(id, callback) {
    function processContextUnregister(body, innerCallback) {
        innerCallback(null);
    }

    logger.debug(context, &#039;Updating device register in NGSI Service&#039;);

    async.waterfall([
        async.apply(registry.get, id),
        async.apply(sendRegistrations, true),
        processContextUnregister,
        async.apply(registry.remove, id)
    ], function(error) {
        callback(error);
    });
}

/**
 * Updates the register of an existing device identified by the Id and Type in the Context Broker, and the internal
 * registry.
 *
 * The device id and type are required fields for a registration updated. Only the following attributes will be
 * updated: lazy, active and internalId. Any other change will be ignored. The registration for the active attributes
 * of the updated entity will be updated if existing, and created if not.
 *
 * @param {Object} deviceObj                    Object with all the device information (mandatory).
 */
function updateRegisterDevice(deviceObj, callback) {
    if (!deviceObj.id || !deviceObj.type) {
        callback(new errors.MissingAttributes(&#039;Id or device missing&#039;));
        return;
    }

    logger.debug(context, &#039;Update provisioned device in NGSI Service&#039;);

    function combineWithNewDevice(newDevice, oldDevice, callback) {
        if (oldDevice) {
            oldDevice.internalId = newDevice.internalId;
            oldDevice.lazy = newDevice.lazy;
            oldDevice.active = newDevice.active;
            oldDevice.name = newDevice.name;
            oldDevice.type = newDevice.type;
            oldDevice.timezone = newDevice.timezone;

            callback(null, oldDevice);
        } else {
            callback(new errors.DeviceNotFound(newDevice.id));
        }
    }

    async.waterfall([
        async.apply(registry.get, deviceObj.id),
        async.apply(combineWithNewDevice, deviceObj),
        async.apply(sendRegistrations, false),
        async.apply(processContextRegistration, deviceObj),
        registry.update
    ], callback);
}

/**
 * Return a list of all the devices registered in the system. This function can be invoked in two different ways:
 * with just one parameter (the callback) or with three parameters (including limit and offset).
 *
 * @param {String} service      Service for which the devices are requested.
 * @param {String} subservice   Subservice inside the service for which the devices are requested.
 * @param {Number} limit        Maximum number of entries to return.
 * @param {Number} offset       Number of entries to skip for pagination.
 */
function listDevices(service, subservice, limit, offset, callback) {
    if (!callback) {
        callback = limit;
    }

    registry.list(service, subservice, limit, offset, callback);
}

/**
 * Retrieve a device from the device registry.
 *
 * @param {String} deviceId         ID of the device to be found.
 */
function getDevice(deviceId, callback) {
    registry.get(deviceId, callback);
}

/**
 * Retrieve a device from the registry based on its entity name.
 *
 * @param {String} deviceName       Name of the entity associated to a device.
 */
function getDeviceByName(deviceName, callback) {
    registry.getByName(deviceName, callback);
}

/**
 * Wraps a function, throwing an exception if the function is invoked before the registry is initialized.
 *
 * @param {Function} fn                 Original function to wrap.
 * @return {Function}                   Wrapped function.
 */
function checkRegistry(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments),
            callbacks = args.slice(-1);

        if (registry) {
            fn.apply(null, args);
        } else if (callbacks &amp;&amp; callbacks.length === 1 &amp;&amp; (typeof callbacks[0] === &#039;function&#039;)) {
            logger.error(context, &#039;Tried to access device information before a registry was available&#039;);
            callbacks[0](new errors.RegistryNotAvailable());
        } else {
            logger.error(context, &#039;Tried to access device information without providing a callback&#039;);
        }
    };
}

/**
 * Initializes the NGSI service. The initialization requires a configuration object and a reference to a device
 * registry.
 *
 * @param {Object} newRegistry              Reference to a device registry, where the devices information are stored.
 * @param {Object} newGroupRegistry         Reference to a group registry, where the groups information are stored.
 * @param {Object} newConfig                Configuration object.
 */
function init(newRegistry, newGroupRegistry, newConfig, callback) {
    registry = newRegistry;
    groupRegistry = newGroupRegistry;
    config = newConfig;

    callback(null);
}

exports.init = init;
exports.listDevices = checkRegistry(listDevices);
exports.getDevice = checkRegistry(getDevice);
exports.getDeviceByName = checkRegistry(getDeviceByName);
exports.register = registerDevice;
exports.updateRegister = updateRegisterDevice;
exports.unregister = unregisterDevice;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
